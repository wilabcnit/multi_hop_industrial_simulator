"""
    Functions to choose the next action to be taken by the UE
"""

import numpy as np

from multi_hop_industrial_simulator.network.ue import Ue
from multi_hop_industrial_simulator.network.packet import Packet
from numpy import ndarray
from multi_hop_industrial_simulator.utils.utils_for_tb_ualoha_with_dqn import get_max_index, select_input_DRL
from multi_hop_industrial_simulator.utils.read_inputs import read_inputs

inputs = read_inputs('inputs.yaml')
DDQN = inputs.get('rl').get('agent').get('DDQN')
_3DQN = inputs.get('rl').get('agent').get('3DQN')
Rainbow_DQN = inputs.get('rl').get('agent').get('Rainbow_DQN')
DDQN_new_state = inputs.get('rl').get('agent').get('New_state')
DRL_input_nodes_number = inputs.get('rl').get('agent').get('DRL_nodes_number')
DRL_input_type_state = inputs.get('rl').get('agent').get('DRL_type_state')

def choose_next_action_tb_no_RL(input_ue: Ue, input_enable_print: bool = False):
    """Choose the next action to be taken by the UE when the UE does not use RL {unicast, broadcast, forced broadcast}

    Args:
      input_ue: UE object
      input_enable_print: boolean to enable print
      input_ue: Ue: 
      input_enable_print: bool:  (Default value = False)

    Returns:
      action: None

    """

    counter_fw = 0
    for packet in input_ue.ul_buffer.buffer_packet_list:
        if packet.get_data_to_be_forwarded_bool() is True:
            counter_fw += 1

    if counter_fw == 0:
        input_ue.set_relay_bool(relay_bool=False)
    else:
        input_ue.set_relay_bool(relay_bool=True)

    if input_ue.new_action_bool is True:

        input_ue.new_action_bool = False
        for packet in input_ue.get_updated_packet_list():
            if packet.get_data_to_be_forwarded_bool() is False:
                input_ue.action_packet_id = packet.get_id()
                break

        if input_enable_print:
            print("UE ", input_ue.get_ue_id(), "set action packet id to: ",
                  input_ue.action_packet_id)
            print("UE ", input_ue.get_ue_id(), " neighbour table: ", input_ue.obs[0])
            print("UE ", input_ue.get_ue_id(), " ack rx: ", input_ue.obs[1])
            print("UE ", input_ue.get_ue_id(), " TTL: ", input_ue.obs[3])
            print("UE ", input_ue.get_ue_id(), " bs seen: ", input_ue.obs[4])

        # Check if no force broadcasting has not to be done
        if (input_ue.next_action is None or
            (input_ue.next_action == 3 and (input_ue.obs[0][-1] == 1 or np.sum(input_ue.obs[0] * input_ue.obs[4]) > 0))):
            if np.sum(input_ue.obs[
                          0]) == 0:
                # Forced Broadcast
                input_ue.set_last_action(input_last_action=2)
                input_ue.set_broadcast_bool(
                    input_broadcast_bool=True)
                input_ue.forced_broadcast_actions_counter += 1
                input_ue.reset_temp_obs()
                if input_enable_print:
                    print("UE ", input_ue.get_ue_id(),
                          " has no neighbours -> Forced Broadcasting")

            else:
                # Unicast
                input_ue.set_last_action(input_last_action=0)

                if input_ue.get_last_action() == 0:

                    input_ue.set_broadcast_bool(
                        input_broadcast_bool=False)
                    # The UE has to choose a unicast address to send the packet to
                    input_ue.set_unicast_rx_address(input_unicast_rx_address=input_ue.neighbour_table[
                        get_max_index(input_ue.obs[0], input_ue.obs[1], input_ue.obs[2], input_ue.obs[4])])
                    input_ue.set_unicast_rx_index(
                        input_unicast_rx_index=get_max_index(input_ue.obs[0], input_ue.obs[1],
                                                             input_ue.obs[2], input_ue.obs[4]))
                    input_ue.copy_unicast_rx_address = input_ue.unicast_rx_address
                    if input_enable_print:
                        print("UE ", input_ue.get_ue_id(), " has chosen unicast towards ",
                              input_ue.get_unicast_rx_address())

        # The UE has received a packet generated by itself
        elif (input_ue.next_action == 3 and input_ue.obs[0][-1] == 0 and np.sum(input_ue.obs[0] * input_ue.obs[4]) == 0):
            # Forced Broadcast
            input_ue.next_action = None
            input_ue.set_last_action(input_last_action=2)
            input_ue.set_broadcast_bool(
                input_broadcast_bool=True)
            input_ue.forced_broadcast_actions_counter += 1
            input_ue.reset_temp_obs()
            if input_enable_print:
                print("UE ", input_ue.get_ue_id(),
                      " has received a packet generated by itself -> Forced Broadcasting")

        # Assign the address to the packets in the UL buffer
        for packet in input_ue.ul_buffer.buffer_packet_list:
            if input_ue.get_broadcast_bool() is False:
                packet.address = str(input_ue.get_unicast_rx_address())
            else:
                packet.address = "-1"

############### AODV ########################

def choose_next_action_aodv(input_ue: Ue, input_enable_print: bool = False):
    """Choose the next action to be taken by the UE when the UE does not use RL and the protocol is AODV

    Args:
      input_ue: UE object
      input_enable_print: boolean to enable print
      input_ue: Ue: 
      input_enable_print: bool:  (Default value = False)

    Returns:
      action: None

    """

    counter_fw = 0
    for packet in input_ue.ul_buffer.buffer_packet_list:
        if packet.get_data_to_be_forwarded_bool() is True:
            counter_fw += 1

    # Check if the UE has to forward a packet
    if counter_fw == 0:
        input_ue.set_relay_bool(relay_bool=False)
    else:
        input_ue.set_relay_bool(relay_bool=True)

    input_ue.new_action_bool = False
    for packet in input_ue.get_updated_packet_list():
        if packet.get_data_to_be_forwarded_bool() is False:
            input_ue.action_packet_id = packet.get_id()
            break

    if input_enable_print:
        print("UE ", input_ue.get_ue_id(), "set action packet id to: ",
              input_ue.action_packet_id)
        print("UE ", input_ue.get_ue_id(), " neighbour table: ", input_ue.obs[0])
        print("UE ", input_ue.get_ue_id(), " ack rx: ", input_ue.obs[1])
        print("UE ", input_ue.get_ue_id(), " TTL: ", input_ue.obs[3])
        print("UE ", input_ue.get_ue_id(), " bs seen: ", input_ue.obs[4])

    # UE has already received the RREPLY -> check if the TTL for that next hop is not None
    if input_ue.unicast_address is None or input_ue.next_action == 3:
        # Forced Broadcast
        input_ue.set_last_action(input_last_action=2)
        input_ue.set_broadcast_bool(input_broadcast_bool=True)
        input_ue.forced_broadcast_actions_counter += 1
        input_ue.reset_temp_obs()
        input_ue.reset_obs()
        if input_enable_print:
            print("UE ", input_ue.get_ue_id(),
                  " needs to resend the RREQ")
        input_ue.new_control_plane = True
        input_ue.set_unicast_rx_address(input_unicast_rx_address=None)
        input_ue.set_unicast_rx_index(input_unicast_rx_index=None)

    elif input_ue.unicast_address is not None and input_ue.next_action != 3:
        # Unicast
        input_ue.set_last_action(input_last_action=0)
        input_ue.set_broadcast_bool(input_broadcast_bool=False)
        index = input_ue.neighbour_table.index(str(input_ue.unicast_address))
        input_ue.set_unicast_rx_address(input_unicast_rx_address=input_ue.neighbour_table[index])
        input_ue.set_unicast_rx_index(input_unicast_rx_index=index)
        if input_enable_print:
            print("UE ", input_ue.get_ue_id(), " has chosen unicast towards ",
                  input_ue.get_unicast_rx_address())

    input_ue.next_action = None

    # Assign the address to the packets in the UL buffer
    for packet in input_ue.ul_buffer.buffer_packet_list:
        if input_ue.get_broadcast_bool() is False:
            packet.address = str(input_ue.get_unicast_rx_address())
        else:
            packet.address = "-1"
